// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/berachain/stargazer/wasp/models"
)

func newEthAccount(db *gorm.DB, opts ...gen.DOOption) ethAccount {
	_ethAccount := ethAccount{}

	_ethAccount.ethAccountDo.UseDB(db, opts...)
	_ethAccount.ethAccountDo.UseModel(&models.EthAccount{})

	tableName := _ethAccount.ethAccountDo.TableName()
	_ethAccount.ALL = field.NewAsterisk(tableName)
	_ethAccount.ID = field.NewInt64(tableName, "id")
	_ethAccount.Address = field.NewBytes(tableName, "address")
	_ethAccount.Alias_ = field.NewString(tableName, "alias")
	_ethAccount.Balance = field.NewString(tableName, "balance")
	_ethAccount.IsContract = field.NewBool(tableName, "is_contract")
	_ethAccount.Contract = ethAccountHasOneContract{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Contract", "models.Contract"),
		Abi: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Contract.Abi", "models.Abi"),
		},
	}

	_ethAccount.Erc721Balance = ethAccountHasManyErc721Balance{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Erc721Balance", "models.Erc721Balance"),
		TokenIds: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Erc721Balance.TokenIds", "models.Erc721Tokens"),
		},
	}

	_ethAccount.Erc20Balance = ethAccountHasManyErc20Balance{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Erc20Balance", "models.Erc20Balance"),
	}

	_ethAccount.fillFieldMap()

	return _ethAccount
}

type ethAccount struct {
	ethAccountDo ethAccountDo

	ALL        field.Asterisk
	ID         field.Int64
	Address    field.Bytes
	Alias_     field.String
	Balance    field.String
	IsContract field.Bool
	Contract   ethAccountHasOneContract

	Erc721Balance ethAccountHasManyErc721Balance

	Erc20Balance ethAccountHasManyErc20Balance

	fieldMap map[string]field.Expr
}

func (e ethAccount) Table(newTableName string) *ethAccount {
	e.ethAccountDo.UseTable(newTableName)
	return e.updateTableName(newTableName)
}

func (e ethAccount) As(alias string) *ethAccount {
	e.ethAccountDo.DO = *(e.ethAccountDo.As(alias).(*gen.DO))
	return e.updateTableName(alias)
}

func (e *ethAccount) updateTableName(table string) *ethAccount {
	e.ALL = field.NewAsterisk(table)
	e.ID = field.NewInt64(table, "id")
	e.Address = field.NewBytes(table, "address")
	e.Alias_ = field.NewString(table, "alias")
	e.Balance = field.NewString(table, "balance")
	e.IsContract = field.NewBool(table, "is_contract")

	e.fillFieldMap()

	return e
}

func (e *ethAccount) WithContext(ctx context.Context) IEthAccountDo {
	return e.ethAccountDo.WithContext(ctx)
}

func (e ethAccount) TableName() string { return e.ethAccountDo.TableName() }

func (e ethAccount) Alias() string { return e.ethAccountDo.Alias() }

func (e *ethAccount) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := e.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (e *ethAccount) fillFieldMap() {
	e.fieldMap = make(map[string]field.Expr, 8)
	e.fieldMap["id"] = e.ID
	e.fieldMap["address"] = e.Address
	e.fieldMap["alias"] = e.Alias_
	e.fieldMap["balance"] = e.Balance
	e.fieldMap["is_contract"] = e.IsContract

}

func (e ethAccount) clone(db *gorm.DB) ethAccount {
	e.ethAccountDo.ReplaceConnPool(db.Statement.ConnPool)
	return e
}

func (e ethAccount) replaceDB(db *gorm.DB) ethAccount {
	e.ethAccountDo.ReplaceDB(db)
	return e
}

type ethAccountHasOneContract struct {
	db *gorm.DB

	field.RelationField

	Abi struct {
		field.RelationField
	}
}

func (a ethAccountHasOneContract) Where(conds ...field.Expr) *ethAccountHasOneContract {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a ethAccountHasOneContract) WithContext(ctx context.Context) *ethAccountHasOneContract {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a ethAccountHasOneContract) Model(m *models.EthAccount) *ethAccountHasOneContractTx {
	return &ethAccountHasOneContractTx{a.db.Model(m).Association(a.Name())}
}

type ethAccountHasOneContractTx struct{ tx *gorm.Association }

func (a ethAccountHasOneContractTx) Find() (result *models.Contract, err error) {
	return result, a.tx.Find(&result)
}

func (a ethAccountHasOneContractTx) Append(values ...*models.Contract) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a ethAccountHasOneContractTx) Replace(values ...*models.Contract) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a ethAccountHasOneContractTx) Delete(values ...*models.Contract) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a ethAccountHasOneContractTx) Clear() error {
	return a.tx.Clear()
}

func (a ethAccountHasOneContractTx) Count() int64 {
	return a.tx.Count()
}

type ethAccountHasManyErc721Balance struct {
	db *gorm.DB

	field.RelationField

	TokenIds struct {
		field.RelationField
	}
}

func (a ethAccountHasManyErc721Balance) Where(conds ...field.Expr) *ethAccountHasManyErc721Balance {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a ethAccountHasManyErc721Balance) WithContext(ctx context.Context) *ethAccountHasManyErc721Balance {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a ethAccountHasManyErc721Balance) Model(m *models.EthAccount) *ethAccountHasManyErc721BalanceTx {
	return &ethAccountHasManyErc721BalanceTx{a.db.Model(m).Association(a.Name())}
}

type ethAccountHasManyErc721BalanceTx struct{ tx *gorm.Association }

func (a ethAccountHasManyErc721BalanceTx) Find() (result []*models.Erc721Balance, err error) {
	return result, a.tx.Find(&result)
}

func (a ethAccountHasManyErc721BalanceTx) Append(values ...*models.Erc721Balance) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a ethAccountHasManyErc721BalanceTx) Replace(values ...*models.Erc721Balance) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a ethAccountHasManyErc721BalanceTx) Delete(values ...*models.Erc721Balance) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a ethAccountHasManyErc721BalanceTx) Clear() error {
	return a.tx.Clear()
}

func (a ethAccountHasManyErc721BalanceTx) Count() int64 {
	return a.tx.Count()
}

type ethAccountHasManyErc20Balance struct {
	db *gorm.DB

	field.RelationField
}

func (a ethAccountHasManyErc20Balance) Where(conds ...field.Expr) *ethAccountHasManyErc20Balance {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a ethAccountHasManyErc20Balance) WithContext(ctx context.Context) *ethAccountHasManyErc20Balance {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a ethAccountHasManyErc20Balance) Model(m *models.EthAccount) *ethAccountHasManyErc20BalanceTx {
	return &ethAccountHasManyErc20BalanceTx{a.db.Model(m).Association(a.Name())}
}

type ethAccountHasManyErc20BalanceTx struct{ tx *gorm.Association }

func (a ethAccountHasManyErc20BalanceTx) Find() (result []*models.Erc20Balance, err error) {
	return result, a.tx.Find(&result)
}

func (a ethAccountHasManyErc20BalanceTx) Append(values ...*models.Erc20Balance) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a ethAccountHasManyErc20BalanceTx) Replace(values ...*models.Erc20Balance) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a ethAccountHasManyErc20BalanceTx) Delete(values ...*models.Erc20Balance) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a ethAccountHasManyErc20BalanceTx) Clear() error {
	return a.tx.Clear()
}

func (a ethAccountHasManyErc20BalanceTx) Count() int64 {
	return a.tx.Count()
}

type ethAccountDo struct{ gen.DO }

type IEthAccountDo interface {
	gen.SubQuery
	Debug() IEthAccountDo
	WithContext(ctx context.Context) IEthAccountDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IEthAccountDo
	WriteDB() IEthAccountDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IEthAccountDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IEthAccountDo
	Not(conds ...gen.Condition) IEthAccountDo
	Or(conds ...gen.Condition) IEthAccountDo
	Select(conds ...field.Expr) IEthAccountDo
	Where(conds ...gen.Condition) IEthAccountDo
	Order(conds ...field.Expr) IEthAccountDo
	Distinct(cols ...field.Expr) IEthAccountDo
	Omit(cols ...field.Expr) IEthAccountDo
	Join(table schema.Tabler, on ...field.Expr) IEthAccountDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IEthAccountDo
	RightJoin(table schema.Tabler, on ...field.Expr) IEthAccountDo
	Group(cols ...field.Expr) IEthAccountDo
	Having(conds ...gen.Condition) IEthAccountDo
	Limit(limit int) IEthAccountDo
	Offset(offset int) IEthAccountDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IEthAccountDo
	Unscoped() IEthAccountDo
	Create(values ...*models.EthAccount) error
	CreateInBatches(values []*models.EthAccount, batchSize int) error
	Save(values ...*models.EthAccount) error
	First() (*models.EthAccount, error)
	Take() (*models.EthAccount, error)
	Last() (*models.EthAccount, error)
	Find() ([]*models.EthAccount, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.EthAccount, err error)
	FindInBatches(result *[]*models.EthAccount, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.EthAccount) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IEthAccountDo
	Assign(attrs ...field.AssignExpr) IEthAccountDo
	Joins(fields ...field.RelationField) IEthAccountDo
	Preload(fields ...field.RelationField) IEthAccountDo
	FirstOrInit() (*models.EthAccount, error)
	FirstOrCreate() (*models.EthAccount, error)
	FindByPage(offset int, limit int) (result []*models.EthAccount, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IEthAccountDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (e ethAccountDo) Debug() IEthAccountDo {
	return e.withDO(e.DO.Debug())
}

func (e ethAccountDo) WithContext(ctx context.Context) IEthAccountDo {
	return e.withDO(e.DO.WithContext(ctx))
}

func (e ethAccountDo) ReadDB() IEthAccountDo {
	return e.Clauses(dbresolver.Read)
}

func (e ethAccountDo) WriteDB() IEthAccountDo {
	return e.Clauses(dbresolver.Write)
}

func (e ethAccountDo) Session(config *gorm.Session) IEthAccountDo {
	return e.withDO(e.DO.Session(config))
}

func (e ethAccountDo) Clauses(conds ...clause.Expression) IEthAccountDo {
	return e.withDO(e.DO.Clauses(conds...))
}

func (e ethAccountDo) Returning(value interface{}, columns ...string) IEthAccountDo {
	return e.withDO(e.DO.Returning(value, columns...))
}

func (e ethAccountDo) Not(conds ...gen.Condition) IEthAccountDo {
	return e.withDO(e.DO.Not(conds...))
}

func (e ethAccountDo) Or(conds ...gen.Condition) IEthAccountDo {
	return e.withDO(e.DO.Or(conds...))
}

func (e ethAccountDo) Select(conds ...field.Expr) IEthAccountDo {
	return e.withDO(e.DO.Select(conds...))
}

func (e ethAccountDo) Where(conds ...gen.Condition) IEthAccountDo {
	return e.withDO(e.DO.Where(conds...))
}

func (e ethAccountDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IEthAccountDo {
	return e.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (e ethAccountDo) Order(conds ...field.Expr) IEthAccountDo {
	return e.withDO(e.DO.Order(conds...))
}

func (e ethAccountDo) Distinct(cols ...field.Expr) IEthAccountDo {
	return e.withDO(e.DO.Distinct(cols...))
}

func (e ethAccountDo) Omit(cols ...field.Expr) IEthAccountDo {
	return e.withDO(e.DO.Omit(cols...))
}

func (e ethAccountDo) Join(table schema.Tabler, on ...field.Expr) IEthAccountDo {
	return e.withDO(e.DO.Join(table, on...))
}

func (e ethAccountDo) LeftJoin(table schema.Tabler, on ...field.Expr) IEthAccountDo {
	return e.withDO(e.DO.LeftJoin(table, on...))
}

func (e ethAccountDo) RightJoin(table schema.Tabler, on ...field.Expr) IEthAccountDo {
	return e.withDO(e.DO.RightJoin(table, on...))
}

func (e ethAccountDo) Group(cols ...field.Expr) IEthAccountDo {
	return e.withDO(e.DO.Group(cols...))
}

func (e ethAccountDo) Having(conds ...gen.Condition) IEthAccountDo {
	return e.withDO(e.DO.Having(conds...))
}

func (e ethAccountDo) Limit(limit int) IEthAccountDo {
	return e.withDO(e.DO.Limit(limit))
}

func (e ethAccountDo) Offset(offset int) IEthAccountDo {
	return e.withDO(e.DO.Offset(offset))
}

func (e ethAccountDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IEthAccountDo {
	return e.withDO(e.DO.Scopes(funcs...))
}

func (e ethAccountDo) Unscoped() IEthAccountDo {
	return e.withDO(e.DO.Unscoped())
}

func (e ethAccountDo) Create(values ...*models.EthAccount) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Create(values)
}

func (e ethAccountDo) CreateInBatches(values []*models.EthAccount, batchSize int) error {
	return e.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (e ethAccountDo) Save(values ...*models.EthAccount) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Save(values)
}

func (e ethAccountDo) First() (*models.EthAccount, error) {
	if result, err := e.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.EthAccount), nil
	}
}

func (e ethAccountDo) Take() (*models.EthAccount, error) {
	if result, err := e.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.EthAccount), nil
	}
}

func (e ethAccountDo) Last() (*models.EthAccount, error) {
	if result, err := e.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.EthAccount), nil
	}
}

func (e ethAccountDo) Find() ([]*models.EthAccount, error) {
	result, err := e.DO.Find()
	return result.([]*models.EthAccount), err
}

func (e ethAccountDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.EthAccount, err error) {
	buf := make([]*models.EthAccount, 0, batchSize)
	err = e.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (e ethAccountDo) FindInBatches(result *[]*models.EthAccount, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return e.DO.FindInBatches(result, batchSize, fc)
}

func (e ethAccountDo) Attrs(attrs ...field.AssignExpr) IEthAccountDo {
	return e.withDO(e.DO.Attrs(attrs...))
}

func (e ethAccountDo) Assign(attrs ...field.AssignExpr) IEthAccountDo {
	return e.withDO(e.DO.Assign(attrs...))
}

func (e ethAccountDo) Joins(fields ...field.RelationField) IEthAccountDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Joins(_f))
	}
	return &e
}

func (e ethAccountDo) Preload(fields ...field.RelationField) IEthAccountDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Preload(_f))
	}
	return &e
}

func (e ethAccountDo) FirstOrInit() (*models.EthAccount, error) {
	if result, err := e.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.EthAccount), nil
	}
}

func (e ethAccountDo) FirstOrCreate() (*models.EthAccount, error) {
	if result, err := e.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.EthAccount), nil
	}
}

func (e ethAccountDo) FindByPage(offset int, limit int) (result []*models.EthAccount, count int64, err error) {
	result, err = e.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = e.Offset(-1).Limit(-1).Count()
	return
}

func (e ethAccountDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = e.Count()
	if err != nil {
		return
	}

	err = e.Offset(offset).Limit(limit).Scan(result)
	return
}

func (e ethAccountDo) Scan(result interface{}) (err error) {
	return e.DO.Scan(result)
}

func (e ethAccountDo) Delete(models ...*models.EthAccount) (result gen.ResultInfo, err error) {
	return e.DO.Delete(models)
}

func (e *ethAccountDo) withDO(do gen.Dao) *ethAccountDo {
	e.DO = *do.(*gen.DO)
	return e
}
